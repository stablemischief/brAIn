{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nvar _provider, _providerCalled;\n// src/timeoutManager.ts\nvar defaultTimeoutProvider = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: timeoutId => clearTimeout(timeoutId),\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: intervalId => clearInterval(intervalId)\n};\nvar TimeoutManager = (_provider = /*#__PURE__*/new WeakMap(), _providerCalled = /*#__PURE__*/new WeakMap(), class TimeoutManager {\n  constructor() {\n    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n    // type at app boot; and if we leave that type, then any new timer provider\n    // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n    //\n    // We settle for type safety for the TimeoutProvider type, and accept that\n    // this class is unsafe internally to allow for extension.\n    _classPrivateFieldInitSpec(this, _provider, defaultTimeoutProvider);\n    _classPrivateFieldInitSpec(this, _providerCalled, false);\n  }\n  setTimeoutProvider(provider) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (_classPrivateFieldGet(_providerCalled, this) && provider !== _classPrivateFieldGet(_provider, this)) {\n        console.error(\"[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.\", {\n          previous: _classPrivateFieldGet(_provider, this),\n          provider\n        });\n      }\n    }\n    _classPrivateFieldSet(_provider, this, provider);\n    if (process.env.NODE_ENV !== \"production\") {\n      _classPrivateFieldSet(_providerCalled, this, false);\n    }\n  }\n  setTimeout(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _classPrivateFieldSet(_providerCalled, this, true);\n    }\n    return _classPrivateFieldGet(_provider, this).setTimeout(callback, delay);\n  }\n  clearTimeout(timeoutId) {\n    _classPrivateFieldGet(_provider, this).clearTimeout(timeoutId);\n  }\n  setInterval(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _classPrivateFieldSet(_providerCalled, this, true);\n    }\n    return _classPrivateFieldGet(_provider, this).setInterval(callback, delay);\n  }\n  clearInterval(intervalId) {\n    _classPrivateFieldGet(_provider, this).clearInterval(intervalId);\n  }\n});\nvar timeoutManager = new TimeoutManager();\nfunction systemSetTimeoutZero(callback) {\n  setTimeout(callback, 0);\n}\nexport { TimeoutManager, defaultTimeoutProvider, systemSetTimeoutZero, timeoutManager };","map":{"version":3,"names":["defaultTimeoutProvider","setTimeout","callback","delay","clearTimeout","timeoutId","setInterval","clearInterval","intervalId","TimeoutManager","_provider","WeakMap","_providerCalled","constructor","_classPrivateFieldInitSpec","setTimeoutProvider","provider","process","env","NODE_ENV","_classPrivateFieldGet","console","error","previous","_classPrivateFieldSet","timeoutManager","systemSetTimeoutZero"],"sources":["/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@tanstack/query-core/src/timeoutManager.ts"],"sourcesContent":["/**\n * {@link TimeoutManager} does not support passing arguments to the callback.\n *\n * `(_: void)` is the argument type inferred by TypeScript's default typings for\n * `setTimeout(cb, number)`.\n * If we don't accept a single void argument, then\n * `new Promise(resolve => timeoutManager.setTimeout(resolve, N))` is a type error.\n */\nexport type TimeoutCallback = (_: void) => void\n\n/**\n * Wrapping `setTimeout` is awkward from a typing perspective because platform\n * typings may extend the return type of `setTimeout`. For example, NodeJS\n * typings add `NodeJS.Timeout`; but a non-default `timeoutManager` may not be\n * able to return such a type.\n */\nexport type ManagedTimerId = number | { [Symbol.toPrimitive]: () => number }\n\n/**\n * Backend for timer functions.\n */\nexport type TimeoutProvider<TTimerId extends ManagedTimerId = ManagedTimerId> =\n  {\n    readonly setTimeout: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearTimeout: (timeoutId: TTimerId | undefined) => void\n\n    readonly setInterval: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearInterval: (intervalId: TTimerId | undefined) => void\n  }\n\nexport const defaultTimeoutProvider: TimeoutProvider<\n  ReturnType<typeof setTimeout>\n> = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: (timeoutId) => clearTimeout(timeoutId),\n\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: (intervalId) => clearInterval(intervalId),\n}\n\n/**\n * Allows customization of how timeouts are created.\n *\n * @tanstack/query-core makes liberal use of timeouts to implement `staleTime`\n * and `gcTime`. The default TimeoutManager provider uses the platform's global\n * `setTimeout` implementation, which is known to have scalability issues with\n * thousands of timeouts on the event loop.\n *\n * If you hit this limitation, consider providing a custom TimeoutProvider that\n * coalesces timeouts.\n */\nexport class TimeoutManager implements Omit<TimeoutProvider, 'name'> {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider: TimeoutProvider<any> = defaultTimeoutProvider\n  #providerCalled = false\n\n  setTimeoutProvider<TTimerId extends ManagedTimerId>(\n    provider: TimeoutProvider<TTimerId>,\n  ): void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.#providerCalled && provider !== this.#provider) {\n        // After changing providers, `clearTimeout` will not work as expected for\n        // timeouts from the previous provider.\n        //\n        // Since they may allocate the same timeout ID, clearTimeout may cancel an\n        // arbitrary different timeout, or unexpected no-op.\n        //\n        // We could protect against this by mixing the timeout ID bits\n        // deterministically with some per-provider bits.\n        //\n        // We could internally queue `setTimeout` calls to `TimeoutManager` until\n        // some API call to set the initial provider.\n        console.error(\n          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,\n          { previous: this.#provider, provider },\n        )\n      }\n    }\n\n    this.#provider = provider\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = false\n    }\n  }\n\n  setTimeout(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setTimeout(callback, delay)\n  }\n\n  clearTimeout(timeoutId: ManagedTimerId | undefined): void {\n    this.#provider.clearTimeout(timeoutId)\n  }\n\n  setInterval(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setInterval(callback, delay)\n  }\n\n  clearInterval(intervalId: ManagedTimerId | undefined): void {\n    this.#provider.clearInterval(intervalId)\n  }\n}\n\nexport const timeoutManager = new TimeoutManager()\n\n/**\n * In many cases code wants to delay to the next event loop tick; this is not\n * mediated by {@link timeoutManager}.\n *\n * This function is provided to make auditing the `tanstack/query-core` for\n * incorrect use of system `setTimeout` easier.\n */\nexport function systemSetTimeoutZero(callback: TimeoutCallback): void {\n  setTimeout(callback, 0)\n}\n"],"mappings":";;;;;AA8BO,IAAMA,sBAAA,GAET;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAWFC,UAAA,EAAYA,CAACC,QAAA,EAAUC,KAAA,KAAUF,UAAA,CAAWC,QAAA,EAAUC,KAAK;EAC3DC,YAAA,EAAeC,SAAA,IAAcD,YAAA,CAAaC,SAAS;EAEnDC,WAAA,EAAaA,CAACJ,QAAA,EAAUC,KAAA,KAAUG,WAAA,CAAYJ,QAAA,EAAUC,KAAK;EAC7DI,aAAA,EAAgBC,UAAA,IAAeD,aAAA,CAAcC,UAAU;AACzD;AAaO,IAAMC,cAAA,IAAAC,SAAA,oBAAAC,OAAA,IAAAC,eAAA,oBAAAD,OAAA,IAAN,MAAMF,cAAA,CAAwD;EAAAI,YAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAOnEC,0BAAA,OAAAJ,SAAA,EAAkCV,sBAAA;IAClCc,0BAAA,OAAAF,eAAA,EAAkB;EAAA;EAElBG,mBACEC,QAAA,EACM;IACN,IAAIC,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzC,IAAIC,qBAAA,CAAKR,eAAA,EAAL,IAAK,KAAmBI,QAAA,KAAaI,qBAAA,CAAKV,SAAA,EAAL,IAAK,GAAW;QAYvDW,OAAA,CAAQC,KAAA,+GAEN;UAAEC,QAAA,EAAUH,qBAAA,CAAKV,SAAA,EAAL,IAAK;UAAWM;QAAS,CACvC;MACF;IACF;IAEAQ,qBAAA,CAAKd,SAAA,EAAL,MAAiBM,QAAZ;IACL,IAAIC,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzCK,qBAAA,CAAKZ,eAAA,EAAL,MAAuB,KAAlB;IACP;EACF;EAEAX,WAAWC,QAAA,EAA2BC,KAAA,EAA+B;IACnE,IAAIc,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzCK,qBAAA,CAAKZ,eAAA,EAAL,MAAuB,IAAlB;IACP;IACA,OAAOQ,qBAAA,CAAKV,SAAA,EAAL,IAAK,EAAUT,UAAA,CAAWC,QAAA,EAAUC,KAAK;EAClD;EAEAC,aAAaC,SAAA,EAA6C;IACxDe,qBAAA,CAAKV,SAAA,EAAL,IAAK,EAAUN,YAAA,CAAaC,SAAS;EACvC;EAEAC,YAAYJ,QAAA,EAA2BC,KAAA,EAA+B;IACpE,IAAIc,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzCK,qBAAA,CAAKZ,eAAA,EAAL,MAAuB,IAAlB;IACP;IACA,OAAOQ,qBAAA,CAAKV,SAAA,EAAL,IAAK,EAAUJ,WAAA,CAAYJ,QAAA,EAAUC,KAAK;EACnD;EAEAI,cAAcC,UAAA,EAA8C;IAC1DY,qBAAA,CAAKV,SAAA,EAAL,IAAK,EAAUH,aAAA,CAAcC,UAAU;EACzC;AACF;AAEO,IAAMiB,cAAA,GAAiB,IAAIhB,cAAA,CAAe;AAS1C,SAASiB,qBAAqBxB,QAAA,EAAiC;EACpED,UAAA,CAAWC,QAAA,EAAU,CAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}