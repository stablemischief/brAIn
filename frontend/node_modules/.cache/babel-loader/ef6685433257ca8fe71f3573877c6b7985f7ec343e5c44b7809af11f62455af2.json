{"ast":null,"code":"export class WebSocketClient{constructor(){let baseUrl=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'ws://localhost:8000';this.ws=null;this.url=void 0;this.reconnectAttempts=0;this.maxReconnectAttempts=10;this.reconnectDelay=1000;this.maxReconnectDelay=30000;this.listeners=new Map();this.subscriptions=new Set();this.heartbeatInterval=null;this.reconnectTimeout=null;this.connectionId=null;this.url=\"\".concat(baseUrl,\"/ws/realtime\");}/**\n   * Connect to the WebSocket server\n   */connect(userId,sessionId,channels){return new Promise((resolve,reject)=>{try{// Build connection URL with query parameters\nconst urlParams=new URLSearchParams();if(userId)urlParams.append('user_id',userId);if(sessionId)urlParams.append('session_id',sessionId);if(channels!==null&&channels!==void 0&&channels.length)urlParams.append('channels',channels.join(','));const wsUrl=\"\".concat(this.url,\"?\").concat(urlParams.toString());this.ws=new WebSocket(wsUrl);this.ws.onopen=()=>{console.log('WebSocket connected');this.reconnectAttempts=0;this.startHeartbeat();this.resubscribeToChannels();this.emit('connected',{connected:true});resolve();};this.ws.onmessage=event=>{try{const message=JSON.parse(event.data);this.handleMessage(message);}catch(error){console.error('Failed to parse WebSocket message:',error);}};this.ws.onclose=event=>{console.log('WebSocket disconnected:',event.code,event.reason);this.stopHeartbeat();this.emit('disconnected',{connected:false,code:event.code,reason:event.reason});// Attempt reconnection if not a clean close\nif(event.code!==1000&&this.reconnectAttempts<this.maxReconnectAttempts){this.scheduleReconnect();}};this.ws.onerror=error=>{console.error('WebSocket error:',error);this.emit('error',{error:'WebSocket connection error'});reject(error);};}catch(error){console.error('Failed to create WebSocket connection:',error);reject(error);}});}/**\n   * Disconnect from the WebSocket server\n   */disconnect(){if(this.reconnectTimeout){clearTimeout(this.reconnectTimeout);this.reconnectTimeout=null;}this.stopHeartbeat();if(this.ws&&this.ws.readyState===WebSocket.OPEN){this.ws.close(1000,'Client disconnect');}this.ws=null;this.connectionId=null;this.subscriptions.clear();}/**\n   * Send a message to the server\n   */sendMessage(message){if(this.ws&&this.ws.readyState===WebSocket.OPEN){try{this.ws.send(JSON.stringify(message));}catch(error){console.error('Failed to send WebSocket message:',error);this.emit('error',{error:'Failed to send message'});}}else{console.warn('WebSocket is not connected. Message not sent:',message);}}/**\n   * Subscribe to a channel\n   */subscribe(channel){this.subscriptions.add(channel);if(this.isConnected()){this.sendMessage({type:'subscribe',channel:channel,timestamp:new Date().toISOString()});}}/**\n   * Unsubscribe from a channel\n   */unsubscribe(channel){this.subscriptions.delete(channel);if(this.isConnected()){this.sendMessage({type:'unsubscribe',channel:channel,timestamp:new Date().toISOString()});}}/**\n   * Add event listener\n   */on(event,callback){if(!this.listeners.has(event)){this.listeners.set(event,new Set());}this.listeners.get(event).add(callback);}/**\n   * Remove event listener\n   */off(event,callback){const eventListeners=this.listeners.get(event);if(eventListeners){eventListeners.delete(callback);if(eventListeners.size===0){this.listeners.delete(event);}}}/**\n   * Check if WebSocket is connected\n   */isConnected(){var _this$ws;return((_this$ws=this.ws)===null||_this$ws===void 0?void 0:_this$ws.readyState)===WebSocket.OPEN;}/**\n   * Get connection state\n   */getConnectionState(){if(!this.ws)return'closed';switch(this.ws.readyState){case WebSocket.CONNECTING:return'connecting';case WebSocket.OPEN:return'open';case WebSocket.CLOSING:return'closing';case WebSocket.CLOSED:default:return'closed';}}/**\n   * Get current subscriptions\n   */getSubscriptions(){return Array.from(this.subscriptions);}handleMessage(message){// Handle connection confirmation\nif(message.type==='connection_confirmed'){var _message$payload;this.connectionId=(_message$payload=message.payload)===null||_message$payload===void 0?void 0:_message$payload.connection_id;console.log('Connection confirmed:',this.connectionId);}// Handle subscription confirmation\nif(message.type==='subscription_confirmed'){var _message$payload2;console.log('Subscribed to channel:',(_message$payload2=message.payload)===null||_message$payload2===void 0?void 0:_message$payload2.channel);}// Handle errors\nif(message.type==='error'){console.error('WebSocket server error:',message.payload);this.emit('error',message.payload);return;}// Emit the message to listeners\nthis.emit('message',message);// Emit channel-specific events\nif(message.channel){this.emit(\"channel:\".concat(message.channel),message);}// Emit type-specific events\nthis.emit(\"type:\".concat(message.type),message);}emit(event,data){const eventListeners=this.listeners.get(event);if(eventListeners){eventListeners.forEach(callback=>{try{callback(data);}catch(error){console.error(\"Error in WebSocket event listener for \".concat(event,\":\"),error);}});}}scheduleReconnect(){if(this.reconnectTimeout)return;const delay=Math.min(this.reconnectDelay*Math.pow(2,this.reconnectAttempts),this.maxReconnectDelay);console.log(\"Attempting to reconnect in \".concat(delay,\"ms... (attempt \").concat(this.reconnectAttempts+1,\"/\").concat(this.maxReconnectAttempts,\")\"));this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=null;this.reconnectAttempts++;this.connect();},delay);}resubscribeToChannels(){// Re-subscribe to all channels after reconnection\nthis.subscriptions.forEach(channel=>{this.sendMessage({type:'subscribe',channel:channel,timestamp:new Date().toISOString()});});}startHeartbeat(){this.stopHeartbeat();this.heartbeatInterval=setInterval(()=>{if(this.isConnected()){this.sendMessage({type:'ping',timestamp:new Date().toISOString()});}},30000);// Send ping every 30 seconds\n}stopHeartbeat(){if(this.heartbeatInterval){clearInterval(this.heartbeatInterval);this.heartbeatInterval=null;}}}// Singleton WebSocket client instance\nlet wsClientInstance=null;/**\n * Get the singleton WebSocket client instance\n */export const getWebSocketClient=()=>{if(!wsClientInstance){const baseUrl=process.env.NODE_ENV==='production'?'wss://your-domain.com'// Replace with your production WebSocket URL\n:'ws://localhost:8000';wsClientInstance=new WebSocketClient(baseUrl);}return wsClientInstance;};/**\n * WebSocket event types for type safety\n */export const WS_EVENTS={CONNECTED:'connected',DISCONNECTED:'disconnected',ERROR:'error',MESSAGE:'message',PROCESSING_STATUS:'type:processing_status',SYSTEM_HEALTH:'type:system_health',COST_UPDATE:'type:cost_update',NEW_DOCUMENT:'type:new_document',JOB_PROGRESS:'type:job_progress'};/**\n * Channel names for subscriptions\n */export const WS_CHANNELS={PROCESSING:'processing',SYSTEM_HEALTH:'system_health',COST_MONITORING:'cost_monitoring',USER_ACTIVITY:'user_activity',KNOWLEDGE_GRAPH:'knowledge_graph'};","map":{"version":3,"names":["WebSocketClient","constructor","baseUrl","arguments","length","undefined","ws","url","reconnectAttempts","maxReconnectAttempts","reconnectDelay","maxReconnectDelay","listeners","Map","subscriptions","Set","heartbeatInterval","reconnectTimeout","connectionId","concat","connect","userId","sessionId","channels","Promise","resolve","reject","urlParams","URLSearchParams","append","join","wsUrl","toString","WebSocket","onopen","console","log","startHeartbeat","resubscribeToChannels","emit","connected","onmessage","event","message","JSON","parse","data","handleMessage","error","onclose","code","reason","stopHeartbeat","scheduleReconnect","onerror","disconnect","clearTimeout","readyState","OPEN","close","clear","sendMessage","send","stringify","warn","subscribe","channel","add","isConnected","type","timestamp","Date","toISOString","unsubscribe","delete","on","callback","has","set","get","off","eventListeners","size","_this$ws","getConnectionState","CONNECTING","CLOSING","CLOSED","getSubscriptions","Array","from","_message$payload","payload","connection_id","_message$payload2","forEach","delay","Math","min","pow","setTimeout","setInterval","clearInterval","wsClientInstance","getWebSocketClient","process","env","NODE_ENV","WS_EVENTS","CONNECTED","DISCONNECTED","ERROR","MESSAGE","PROCESSING_STATUS","SYSTEM_HEALTH","COST_UPDATE","NEW_DOCUMENT","JOB_PROGRESS","WS_CHANNELS","PROCESSING","COST_MONITORING","USER_ACTIVITY","KNOWLEDGE_GRAPH"],"sources":["/Users/james/Documents/Product-RD/brAIn/frontend/src/utils/websocket.ts"],"sourcesContent":["import { WebSocketMessage, RealtimeUpdate } from '../types';\n\nexport class WebSocketClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectDelay = 1000;\n  private maxReconnectDelay = 30000;\n  private listeners = new Map<string, Set<Function>>();\n  private subscriptions = new Set<string>();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private connectionId: string | null = null;\n\n  constructor(baseUrl: string = 'ws://localhost:8000') {\n    this.url = `${baseUrl}/ws/realtime`;\n  }\n\n  /**\n   * Connect to the WebSocket server\n   */\n  connect(userId?: string, sessionId?: string, channels?: string[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Build connection URL with query parameters\n        const urlParams = new URLSearchParams();\n        if (userId) urlParams.append('user_id', userId);\n        if (sessionId) urlParams.append('session_id', sessionId);\n        if (channels?.length) urlParams.append('channels', channels.join(','));\n\n        const wsUrl = `${this.url}?${urlParams.toString()}`;\n        \n        this.ws = new WebSocket(wsUrl);\n\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n          this.startHeartbeat();\n          this.resubscribeToChannels();\n          this.emit('connected', { connected: true });\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            this.handleMessage(message);\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('WebSocket disconnected:', event.code, event.reason);\n          this.stopHeartbeat();\n          this.emit('disconnected', { connected: false, code: event.code, reason: event.reason });\n          \n          // Attempt reconnection if not a clean close\n          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          }\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          this.emit('error', { error: 'WebSocket connection error' });\n          reject(error);\n        };\n\n      } catch (error) {\n        console.error('Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect from the WebSocket server\n   */\n  disconnect(): void {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    this.stopHeartbeat();\n    \n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.close(1000, 'Client disconnect');\n    }\n    \n    this.ws = null;\n    this.connectionId = null;\n    this.subscriptions.clear();\n  }\n\n  /**\n   * Send a message to the server\n   */\n  sendMessage(message: any): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      try {\n        this.ws.send(JSON.stringify(message));\n      } catch (error) {\n        console.error('Failed to send WebSocket message:', error);\n        this.emit('error', { error: 'Failed to send message' });\n      }\n    } else {\n      console.warn('WebSocket is not connected. Message not sent:', message);\n    }\n  }\n\n  /**\n   * Subscribe to a channel\n   */\n  subscribe(channel: string): void {\n    this.subscriptions.add(channel);\n    \n    if (this.isConnected()) {\n      this.sendMessage({\n        type: 'subscribe',\n        channel: channel,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\n   * Unsubscribe from a channel\n   */\n  unsubscribe(channel: string): void {\n    this.subscriptions.delete(channel);\n    \n    if (this.isConnected()) {\n      this.sendMessage({\n        type: 'unsubscribe',\n        channel: channel,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\n   * Add event listener\n   */\n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off(event: string, callback: Function): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(callback);\n      if (eventListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Get connection state\n   */\n  getConnectionState(): 'connecting' | 'open' | 'closing' | 'closed' {\n    if (!this.ws) return 'closed';\n    \n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'open';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n      default:\n        return 'closed';\n    }\n  }\n\n  /**\n   * Get current subscriptions\n   */\n  getSubscriptions(): string[] {\n    return Array.from(this.subscriptions);\n  }\n\n  private handleMessage(message: WebSocketMessage): void {\n    // Handle connection confirmation\n    if (message.type === 'connection_confirmed') {\n      this.connectionId = message.payload?.connection_id;\n      console.log('Connection confirmed:', this.connectionId);\n    }\n\n    // Handle subscription confirmation\n    if (message.type === 'subscription_confirmed') {\n      console.log('Subscribed to channel:', message.payload?.channel);\n    }\n\n    // Handle errors\n    if (message.type === 'error') {\n      console.error('WebSocket server error:', message.payload);\n      this.emit('error', message.payload);\n      return;\n    }\n\n    // Emit the message to listeners\n    this.emit('message', message);\n    \n    // Emit channel-specific events\n    if (message.channel) {\n      this.emit(`channel:${message.channel}`, message);\n    }\n\n    // Emit type-specific events\n    this.emit(`type:${message.type}`, message);\n  }\n\n  private emit(event: string, data: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in WebSocket event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (this.reconnectTimeout) return;\n\n    const delay = Math.min(\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts),\n      this.maxReconnectDelay\n    );\n\n    console.log(`Attempting to reconnect in ${delay}ms... (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = null;\n      this.reconnectAttempts++;\n      this.connect();\n    }, delay);\n  }\n\n  private resubscribeToChannels(): void {\n    // Re-subscribe to all channels after reconnection\n    this.subscriptions.forEach(channel => {\n      this.sendMessage({\n        type: 'subscribe',\n        channel: channel,\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n\n  private startHeartbeat(): void {\n    this.stopHeartbeat();\n    \n    this.heartbeatInterval = setInterval(() => {\n      if (this.isConnected()) {\n        this.sendMessage({\n          type: 'ping',\n          timestamp: new Date().toISOString()\n        });\n      }\n    }, 30000); // Send ping every 30 seconds\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n}\n\n// Singleton WebSocket client instance\nlet wsClientInstance: WebSocketClient | null = null;\n\n/**\n * Get the singleton WebSocket client instance\n */\nexport const getWebSocketClient = (): WebSocketClient => {\n  if (!wsClientInstance) {\n    const baseUrl = process.env.NODE_ENV === 'production' \n      ? 'wss://your-domain.com'  // Replace with your production WebSocket URL\n      : 'ws://localhost:8000';\n    \n    wsClientInstance = new WebSocketClient(baseUrl);\n  }\n  \n  return wsClientInstance;\n};\n\n/**\n * WebSocket event types for type safety\n */\nexport const WS_EVENTS = {\n  CONNECTED: 'connected',\n  DISCONNECTED: 'disconnected',\n  ERROR: 'error',\n  MESSAGE: 'message',\n  PROCESSING_STATUS: 'type:processing_status',\n  SYSTEM_HEALTH: 'type:system_health',\n  COST_UPDATE: 'type:cost_update',\n  NEW_DOCUMENT: 'type:new_document',\n  JOB_PROGRESS: 'type:job_progress',\n} as const;\n\n/**\n * Channel names for subscriptions\n */\nexport const WS_CHANNELS = {\n  PROCESSING: 'processing',\n  SYSTEM_HEALTH: 'system_health',\n  COST_MONITORING: 'cost_monitoring',\n  USER_ACTIVITY: 'user_activity',\n  KNOWLEDGE_GRAPH: 'knowledge_graph',\n} as const;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}