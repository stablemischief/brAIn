{"ast":null,"code":"import _objectSpread from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectDestructuringEmpty from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js\";\nimport _classPrivateMethodInitSpec from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _Class_brand;\n// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nimport { timeoutManager } from \"./timeoutManager.js\";\nvar QueryObserver = (_client = /*#__PURE__*/new WeakMap(), _currentQuery = /*#__PURE__*/new WeakMap(), _currentQueryInitialState = /*#__PURE__*/new WeakMap(), _currentResult = /*#__PURE__*/new WeakMap(), _currentResultState = /*#__PURE__*/new WeakMap(), _currentResultOptions = /*#__PURE__*/new WeakMap(), _currentThenable = /*#__PURE__*/new WeakMap(), _selectError = /*#__PURE__*/new WeakMap(), _selectFn = /*#__PURE__*/new WeakMap(), _selectResult = /*#__PURE__*/new WeakMap(), _lastQueryWithDefinedData = /*#__PURE__*/new WeakMap(), _staleTimeoutId = /*#__PURE__*/new WeakMap(), _refetchIntervalId = /*#__PURE__*/new WeakMap(), _currentRefetchInterval = /*#__PURE__*/new WeakMap(), _trackedProps = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _client, void 0);\n    _classPrivateFieldInitSpec(this, _currentQuery, void 0);\n    _classPrivateFieldInitSpec(this, _currentQueryInitialState, void 0);\n    _classPrivateFieldInitSpec(this, _currentResult, void 0);\n    _classPrivateFieldInitSpec(this, _currentResultState, void 0);\n    _classPrivateFieldInitSpec(this, _currentResultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _currentThenable, void 0);\n    _classPrivateFieldInitSpec(this, _selectError, void 0);\n    _classPrivateFieldInitSpec(this, _selectFn, void 0);\n    _classPrivateFieldInitSpec(this, _selectResult, void 0);\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    _classPrivateFieldInitSpec(this, _lastQueryWithDefinedData, void 0);\n    _classPrivateFieldInitSpec(this, _staleTimeoutId, void 0);\n    _classPrivateFieldInitSpec(this, _refetchIntervalId, void 0);\n    _classPrivateFieldInitSpec(this, _currentRefetchInterval, void 0);\n    _classPrivateFieldInitSpec(this, _trackedProps, /* @__PURE__ */new Set());\n    this.options = options;\n    _classPrivateFieldSet(_client, this, client);\n    _classPrivateFieldSet(_selectError, this, null);\n    _classPrivateFieldSet(_currentThenable, this, pendingThenable());\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      _classPrivateFieldGet(_currentQuery, this).addObserver(this);\n      if (shouldFetchOnMount(_classPrivateFieldGet(_currentQuery, this), this.options)) {\n        _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n      } else {\n        this.updateResult();\n      }\n      _assertClassBrand(_Class_brand, this, _updateTimers).call(this);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(_classPrivateFieldGet(_currentQuery, this), this.options, this.options.refetchOnReconnect);\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(_classPrivateFieldGet(_currentQuery, this), this.options, this.options.refetchOnWindowFocus);\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    _assertClassBrand(_Class_brand, this, _clearStaleTimeout).call(this);\n    _assertClassBrand(_Class_brand, this, _clearRefetchInterval).call(this);\n    _classPrivateFieldGet(_currentQuery, this).removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n    this.options = _classPrivateFieldGet(_client, this).defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n    }\n    _assertClassBrand(_Class_brand, this, _updateQuery).call(this);\n    _classPrivateFieldGet(_currentQuery, this).setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      _classPrivateFieldGet(_client, this).getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: _classPrivateFieldGet(_currentQuery, this),\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(_classPrivateFieldGet(_currentQuery, this), prevQuery, this.options, prevOptions)) {\n      _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n    }\n    this.updateResult();\n    if (mounted && (_classPrivateFieldGet(_currentQuery, this) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(_currentQuery, this)) || resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(_currentQuery, this)) !== resolveStaleTime(prevOptions.staleTime, _classPrivateFieldGet(_currentQuery, this)))) {\n      _assertClassBrand(_Class_brand, this, _updateStaleTimeout).call(this);\n    }\n    const nextRefetchInterval = _assertClassBrand(_Class_brand, this, _computeRefetchInterval).call(this);\n    if (mounted && (_classPrivateFieldGet(_currentQuery, this) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(_currentQuery, this)) || nextRefetchInterval !== _classPrivateFieldGet(_currentRefetchInterval, this))) {\n      _assertClassBrand(_Class_brand, this, _updateRefetchInterval).call(this, nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      _classPrivateFieldSet(_currentResult, this, result);\n      _classPrivateFieldSet(_currentResultOptions, this, this.options);\n      _classPrivateFieldSet(_currentResultState, this, _classPrivateFieldGet(_currentQuery, this).state);\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return _classPrivateFieldGet(_currentResult, this);\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked === null || onPropTracked === void 0 || onPropTracked(key);\n        if (key === \"promise\" && !this.options.experimental_prefetchInRender && _classPrivateFieldGet(_currentThenable, this).status === \"pending\") {\n          _classPrivateFieldGet(_currentThenable, this).reject(new Error(\"experimental_prefetchInRender feature flag is not enabled\"));\n        }\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    _classPrivateFieldGet(_trackedProps, this).add(key);\n  }\n  getCurrentQuery() {\n    return _classPrivateFieldGet(_currentQuery, this);\n  }\n  refetch() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      options = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));\n    return this.fetch(_objectSpread({}, options));\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = _classPrivateFieldGet(_client, this).defaultQueryOptions(options);\n    const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n    return _assertClassBrand(_Class_brand, this, _executeFetch).call(this, _objectSpread(_objectSpread({}, fetchOptions), {}, {\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) !== null && _fetchOptions$cancelR !== void 0 ? _fetchOptions$cancelR : true\n    })).then(() => {\n      this.updateResult();\n      return _classPrivateFieldGet(_currentResult, this);\n    });\n  }\n  createResult(query, options) {\n    const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n    const prevOptions = this.options;\n    const prevResult = _classPrivateFieldGet(_currentResult, this);\n    const prevResultState = _classPrivateFieldGet(_currentResultState, this);\n    const prevResultOptions = _classPrivateFieldGet(_currentResultOptions, this);\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : _classPrivateFieldGet(_currentQueryInitialState, this);\n    const {\n      state\n    } = query;\n    let newState = _objectSpread({}, state);\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = _objectSpread(_objectSpread({}, newState), fetchState(state.data, query.options));\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let {\n      error,\n      errorUpdatedAt,\n      status\n    } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult !== null && prevResult !== void 0 && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions === null || prevResultOptions === void 0 ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        var _classPrivateFieldGet2;\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_classPrivateFieldGet2 = _classPrivateFieldGet(_lastQueryWithDefinedData, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.state.data, _classPrivateFieldGet(_lastQueryWithDefinedData, this)) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === (prevResultState === null || prevResultState === void 0 ? void 0 : prevResultState.data) && options.select === _classPrivateFieldGet(_selectFn, this)) {\n        data = _classPrivateFieldGet(_selectResult, this);\n      } else {\n        try {\n          _classPrivateFieldSet(_selectFn, this, options.select);\n          data = options.select(data);\n          data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, data, options);\n          _classPrivateFieldSet(_selectResult, this, data);\n          _classPrivateFieldSet(_selectError, this, null);\n        } catch (selectError) {\n          _classPrivateFieldSet(_selectError, this, selectError);\n        }\n      }\n    }\n    if (_classPrivateFieldGet(_selectError, this)) {\n      error = _classPrivateFieldGet(_selectError, this);\n      data = _classPrivateFieldGet(_selectResult, this);\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: _classPrivateFieldGet(_currentThenable, this),\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = thenable => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = _classPrivateFieldSet(_currentThenable, this, nextResult.promise = pendingThenable());\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = _classPrivateFieldGet(_currentThenable, this);\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = _classPrivateFieldGet(_currentResult, this);\n    const nextResult = this.createResult(_classPrivateFieldGet(_currentQuery, this), this.options);\n    _classPrivateFieldSet(_currentResultState, this, _classPrivateFieldGet(_currentQuery, this).state);\n    _classPrivateFieldSet(_currentResultOptions, this, this.options);\n    if (_classPrivateFieldGet(_currentResultState, this).data !== void 0) {\n      _classPrivateFieldSet(_lastQueryWithDefinedData, this, _classPrivateFieldGet(_currentQuery, this));\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    _classPrivateFieldSet(_currentResult, this, nextResult);\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !_classPrivateFieldGet(_trackedProps, this).size) {\n        return true;\n      }\n      const includedProps = new Set(notifyOnChangePropsValue !== null && notifyOnChangePropsValue !== void 0 ? notifyOnChangePropsValue : _classPrivateFieldGet(_trackedProps, this));\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(_classPrivateFieldGet(_currentResult, this)).some(key => {\n        const typedKey = key;\n        const changed = _classPrivateFieldGet(_currentResult, this)[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    _assertClassBrand(_Class_brand, this, _notify).call(this, {\n      listeners: shouldNotifyListeners()\n    });\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      _assertClassBrand(_Class_brand, this, _updateTimers).call(this);\n    }\n  }\n});\nfunction _executeFetch(fetchOptions) {\n  _assertClassBrand(_Class_brand, this, _updateQuery).call(this);\n  let promise = _classPrivateFieldGet(_currentQuery, this).fetch(this.options, fetchOptions);\n  if (!(fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n}\nfunction _updateStaleTimeout() {\n  _assertClassBrand(_Class_brand, this, _clearStaleTimeout).call(this);\n  const staleTime = resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(_currentQuery, this));\n  if (isServer || _classPrivateFieldGet(_currentResult, this).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n  const time = timeUntilStale(_classPrivateFieldGet(_currentResult, this).dataUpdatedAt, staleTime);\n  const timeout = time + 1;\n  _classPrivateFieldSet(_staleTimeoutId, this, timeoutManager.setTimeout(() => {\n    if (!_classPrivateFieldGet(_currentResult, this).isStale) {\n      this.updateResult();\n    }\n  }, timeout));\n}\nfunction _computeRefetchInterval() {\n  var _ref2;\n  return (_ref2 = typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(_classPrivateFieldGet(_currentQuery, this)) : this.options.refetchInterval) !== null && _ref2 !== void 0 ? _ref2 : false;\n}\nfunction _updateRefetchInterval(nextInterval) {\n  _assertClassBrand(_Class_brand, this, _clearRefetchInterval).call(this);\n  _classPrivateFieldSet(_currentRefetchInterval, this, nextInterval);\n  if (isServer || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) === false || !isValidTimeout(_classPrivateFieldGet(_currentRefetchInterval, this)) || _classPrivateFieldGet(_currentRefetchInterval, this) === 0) {\n    return;\n  }\n  _classPrivateFieldSet(_refetchIntervalId, this, timeoutManager.setInterval(() => {\n    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n    }\n  }, _classPrivateFieldGet(_currentRefetchInterval, this)));\n}\nfunction _updateTimers() {\n  _assertClassBrand(_Class_brand, this, _updateStaleTimeout).call(this);\n  _assertClassBrand(_Class_brand, this, _updateRefetchInterval).call(this, _assertClassBrand(_Class_brand, this, _computeRefetchInterval).call(this));\n}\nfunction _clearStaleTimeout() {\n  if (_classPrivateFieldGet(_staleTimeoutId, this)) {\n    timeoutManager.clearTimeout(_classPrivateFieldGet(_staleTimeoutId, this));\n    _classPrivateFieldSet(_staleTimeoutId, this, void 0);\n  }\n}\nfunction _clearRefetchInterval() {\n  if (_classPrivateFieldGet(_refetchIntervalId, this)) {\n    timeoutManager.clearInterval(_classPrivateFieldGet(_refetchIntervalId, this));\n    _classPrivateFieldSet(_refetchIntervalId, this, void 0);\n  }\n}\nfunction _updateQuery() {\n  const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), this.options);\n  if (query === _classPrivateFieldGet(_currentQuery, this)) {\n    return;\n  }\n  const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n  _classPrivateFieldSet(_currentQuery, this, query);\n  _classPrivateFieldSet(_currentQueryInitialState, this, query.state);\n  if (this.hasListeners()) {\n    prevQuery === null || prevQuery === void 0 || prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n}\nfunction _notify(notifyOptions) {\n  notifyManager.batch(() => {\n    if (notifyOptions.listeners) {\n      this.listeners.forEach(listener => {\n        listener(_classPrivateFieldGet(_currentResult, this));\n      });\n    }\n    _classPrivateFieldGet(_client, this).getQueryCache().notify({\n      query: _classPrivateFieldGet(_currentQuery, this),\n      type: \"observerResultsUpdated\"\n    });\n  });\n}\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport { QueryObserver };","map":{"version":3,"names":["focusManager","notifyManager","fetchState","Subscribable","pendingThenable","isServer","isValidTimeout","noop","replaceData","resolveEnabled","resolveStaleTime","shallowEqualObjects","timeUntilStale","timeoutManager","QueryObserver","_client","WeakMap","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_currentThenable","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","_Class_brand","WeakSet","constructor","client","options","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","Set","_classPrivateFieldSet","bindMethods","setOptions","refetch","bind","onSubscribe","listeners","size","_classPrivateFieldGet","addObserver","shouldFetchOnMount","_assertClassBrand","_executeFetch","call","updateResult","_updateTimers","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","_clearStaleTimeout","_clearRefetchInterval","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","Error","_updateQuery","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","_updateStaleTimeout","nextRefetchInterval","_computeRefetchInterval","_updateRefetchInterval","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","onPropTracked","Proxy","get","target","key","trackProp","experimental_prefetchInRender","status","reject","Reflect","add","getCurrentQuery","_ref","arguments","length","undefined","Object","assign","_objectDestructuringEmpty","fetch","_objectSpread","fetchOptimistic","defaultedOptions","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","newState","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","skipSelect","placeholderData","_classPrivateFieldGet2","select","selectError","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","dataUpdatedAt","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","promise","isEnabled","nextResult","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","value","reason","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","keys","some","typedKey","changed","has","_notify","onQueryUpdate","catch","time","timeout","setTimeout","_ref2","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","notifyOptions","batch","forEach","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","optimisticResult"],"sources":["/Users/james/Documents/Product-RD/brAIn/frontend/node_modules/@tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { timeoutManager } from './timeoutManager'\nimport type { ManagedTimerId } from './timeoutManager'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ManagedTimerId\n  #refetchIntervalId?: ManagedTimerId\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        if (\n          key === 'promise' &&\n          !this.options.experimental_prefetchInRender &&\n          this.#currentThenable.status === 'pending'\n        ) {\n          this.#currentThenable.reject(\n            new Error(\n              'experimental_prefetchInRender feature flag is not enabled',\n            ),\n          )\n        }\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"mappings":";;;;;;;;;AAAA,SAASA,YAAA,QAAoB;AAC7B,SAASC,aAAA,QAAqB;AAC9B,SAASC,UAAA,QAAkB;AAC3B,SAASC,YAAA,QAAoB;AAC7B,SAASC,eAAA,QAAuB;AAChC,SACEC,QAAA,EACAC,cAAA,EACAC,IAAA,EACAC,WAAA,EACAC,cAAA,EACAC,gBAAA,EACAC,mBAAA,EACAC,cAAA,QACK;AACP,SAASC,cAAA,QAAsB;AAyBxB,IAAMC,aAAA,IAAAC,OAAA,oBAAAC,OAAA,IAAAC,aAAA,oBAAAD,OAAA,IAAAE,yBAAA,oBAAAF,OAAA,IAAAG,cAAA,oBAAAH,OAAA,IAAAI,mBAAA,oBAAAJ,OAAA,IAAAK,qBAAA,oBAAAL,OAAA,IAAAM,gBAAA,oBAAAN,OAAA,IAAAO,YAAA,oBAAAP,OAAA,IAAAQ,SAAA,oBAAAR,OAAA,IAAAS,aAAA,oBAAAT,OAAA,IAAAU,yBAAA,oBAAAV,OAAA,IAAAW,eAAA,oBAAAX,OAAA,IAAAY,kBAAA,oBAAAZ,OAAA,IAAAa,uBAAA,oBAAAb,OAAA,IAAAc,aAAA,oBAAAd,OAAA,IAAAe,YAAA,oBAAAC,OAAA,IAAN,MAAMlB,aAAA,SAMHX,YAAA,CAAmD;EAyB3D8B,YACEC,MAAA,EACOC,OAAA,EAOP;IACA,MAAM;IAAAC,2BAAA,OAAAL,YAAA;IAlCRM,0BAAA,OAAAtB,OAAA;IACAsB,0BAAA,OAAApB,aAAA,EAAoE;IACpEoB,0BAAA,OAAAnB,yBAAA,EAA4D;IAC5DmB,0BAAA,OAAAlB,cAAA,EAAqD;IACrDkB,0BAAA,OAAAjB,mBAAA;IACAiB,0BAAA,OAAAhB,qBAAA;IAOAgB,0BAAA,OAAAf,gBAAA;IACAe,0BAAA,OAAAd,YAAA;IACAc,0BAAA,OAAAb,SAAA;IACAa,0BAAA,OAAAZ,aAAA;IAAA;IAAA;IAGAY,0BAAA,OAAAX,yBAAA;IACAW,0BAAA,OAAAV,eAAA;IACAU,0BAAA,OAAAT,kBAAA;IACAS,0BAAA,OAAAR,uBAAA;IACAQ,0BAAA,OAAAP,aAAA,EAAgB,mBAAIQ,GAAA,CAA+B;IAI1C,KAAAH,OAAA,GAAAA,OAAA;IAUPI,qBAAA,CAAKxB,OAAA,EAAL,MAAemB,MAAV;IACLK,qBAAA,CAAKhB,YAAA,EAAL,MAAoB,IAAf;IACLgB,qBAAA,CAAKjB,gBAAA,EAAL,MAAwBlB,eAAA,CAAgB,CAAnC;IAEL,KAAKoC,WAAA,CAAY;IACjB,KAAKC,UAAA,CAAWN,OAAO;EACzB;EAEUK,YAAA,EAAoB;IAC5B,KAAKE,OAAA,GAAU,KAAKA,OAAA,CAAQC,IAAA,CAAK,IAAI;EACvC;EAEUC,YAAA,EAAoB;IAC5B,IAAI,KAAKC,SAAA,CAAUC,IAAA,KAAS,GAAG;MAC7BC,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAc+B,WAAA,CAAY,IAAI;MAEnC,IAAIC,kBAAA,CAAmBF,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GAAe,KAAKkB,OAAO,GAAG;QACxDe,iBAAA,CAAAnB,YAAA,QAAKoB,aAAA,EAAAC,IAAA,CAAL;MACF,OAAO;QACL,KAAKC,YAAA,CAAa;MACpB;MAEAH,iBAAA,CAAAnB,YAAA,QAAKuB,aAAA,EAAAF,IAAA,CAAL;IACF;EACF;EAEUG,cAAA,EAAsB;IAC9B,IAAI,CAAC,KAAKC,YAAA,CAAa,GAAG;MACxB,KAAKC,OAAA,CAAQ;IACf;EACF;EAEAC,uBAAA,EAAkC;IAChC,OAAOC,aAAA,CACLZ,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GACL,KAAKkB,OAAA,EACL,KAAKA,OAAA,CAAQyB,kBACf;EACF;EAEAC,yBAAA,EAAoC;IAClC,OAAOF,aAAA,CACLZ,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GACL,KAAKkB,OAAA,EACL,KAAKA,OAAA,CAAQ2B,oBACf;EACF;EAEAL,QAAA,EAAgB;IACd,KAAKZ,SAAA,GAAY,mBAAIP,GAAA,CAAI;IACzBY,iBAAA,CAAAnB,YAAA,QAAKgC,kBAAA,EAAAX,IAAA,CAAL;IACAF,iBAAA,CAAAnB,YAAA,QAAKiC,qBAAA,EAAAZ,IAAA,CAAL;IACAL,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAcgD,cAAA,CAAe,IAAI;EACxC;EAEAxB,WACEN,OAAA,EAOM;IACN,MAAM+B,WAAA,GAAc,KAAK/B,OAAA;IACzB,MAAMgC,SAAA,GAAYpB,qBAAA,CAAK9B,aAAA,EAAL,IAAK;IAEvB,KAAKkB,OAAA,GAAUY,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQqD,mBAAA,CAAoBjC,OAAO;IAEvD,IACE,KAAKA,OAAA,CAAQkC,OAAA,KAAY,UACzB,OAAO,KAAKlC,OAAA,CAAQkC,OAAA,KAAY,aAChC,OAAO,KAAKlC,OAAA,CAAQkC,OAAA,KAAY,cAChC,OAAO5D,cAAA,CAAe,KAAK0B,OAAA,CAAQkC,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,MAC5D,WACF;MACA,MAAM,IAAIqD,KAAA,CACR,uEACF;IACF;IAEApB,iBAAA,CAAAnB,YAAA,QAAKwC,YAAA,EAAAnB,IAAA,CAAL;IACAL,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAcwB,UAAA,CAAW,KAAKN,OAAO;IAE1C,IACE+B,WAAA,CAAYM,UAAA,IACZ,CAAC7D,mBAAA,CAAoB,KAAKwB,OAAA,EAAS+B,WAAW,GAC9C;MACAnB,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQ0D,aAAA,CAAc,EAAEC,MAAA,CAAO;QAClCC,IAAA,EAAM;QACNC,KAAA,EAAO7B,qBAAA,CAAK9B,aAAA,EAAL,IAAK;QACZ4D,QAAA,EAAU;MACZ,CAAC;IACH;IAEA,MAAMC,OAAA,GAAU,KAAKtB,YAAA,CAAa;IAGlC,IACEsB,OAAA,IACAC,qBAAA,CACEhC,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GACLkD,SAAA,EACA,KAAKhC,OAAA,EACL+B,WACF,GACA;MACAhB,iBAAA,CAAAnB,YAAA,QAAKoB,aAAA,EAAAC,IAAA,CAAL;IACF;IAGA,KAAKC,YAAA,CAAa;IAGlB,IACEyB,OAAA,KACC/B,qBAAA,CAAK9B,aAAA,EAAL,IAAK,MAAkBkD,SAAA,IACtB1D,cAAA,CAAe,KAAK0B,OAAA,CAAQkC,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,MACrDR,cAAA,CAAeyD,WAAA,CAAYG,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,KACxDP,gBAAA,CAAiB,KAAKyB,OAAA,CAAQ6C,SAAA,EAAWjC,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,MACzDP,gBAAA,CAAiBwD,WAAA,CAAYc,SAAA,EAAWjC,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,IAC9D;MACAiC,iBAAA,CAAAnB,YAAA,QAAKkD,mBAAA,EAAA7B,IAAA,CAAL;IACF;IAEA,MAAM8B,mBAAA,GAAsBhC,iBAAA,CAAAnB,YAAA,QAAKoD,uBAAA,EAAA/B,IAAA,CAAL,KAA6B;IAGzD,IACE0B,OAAA,KACC/B,qBAAA,CAAK9B,aAAA,EAAL,IAAK,MAAkBkD,SAAA,IACtB1D,cAAA,CAAe,KAAK0B,OAAA,CAAQkC,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,MACrDR,cAAA,CAAeyD,WAAA,CAAYG,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,KACxDiE,mBAAA,KAAwBnC,qBAAA,CAAKlB,uBAAA,EAAL,IAAK,IAC/B;MACAqB,iBAAA,CAAAnB,YAAA,QAAKqD,sBAAA,EAAAhC,IAAA,CAAL,MAA4B8B,mBAAmB;IACjD;EACF;EAEAG,oBACElD,OAAA,EAOoC;IACpC,MAAMyC,KAAA,GAAQ7B,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQ0D,aAAA,CAAc,EAAEa,KAAA,CAAMvC,qBAAA,CAAKhC,OAAA,EAAL,IAAK,GAASoB,OAAO;IAEtE,MAAMoD,MAAA,GAAS,KAAKC,YAAA,CAAaZ,KAAA,EAAOzC,OAAO;IAE/C,IAAIsD,qCAAA,CAAsC,MAAMF,MAAM,GAAG;MAiBvDhD,qBAAA,CAAKpB,cAAA,EAAL,MAAsBoE,MAAjB;MACLhD,qBAAA,CAAKlB,qBAAA,EAAL,MAA6B,KAAKc,OAA7B;MACLI,qBAAA,CAAKnB,mBAAA,EAAL,MAA2B2B,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAcyE,KAAzC;IACP;IACA,OAAOH,MAAA;EACT;EAEAI,iBAAA,EAAuD;IACrD,OAAO5C,qBAAA,CAAK5B,cAAA,EAAL,IAAK;EACd;EAEAyE,YACEL,MAAA,EACAM,aAAA,EACoC;IACpC,OAAO,IAAIC,KAAA,CAAMP,MAAA,EAAQ;MACvBQ,GAAA,EAAKA,CAACC,MAAA,EAAQC,GAAA,KAAQ;QACpB,KAAKC,SAAA,CAAUD,GAAgC;QAC/CJ,aAAA,aAAAA,aAAA,eAAAA,aAAA,CAAgBI,GAAgC;QAChD,IACEA,GAAA,KAAQ,aACR,CAAC,KAAK9D,OAAA,CAAQgE,6BAAA,IACdpD,qBAAA,CAAKzB,gBAAA,EAAL,IAAK,EAAiB8E,MAAA,KAAW,WACjC;UACArD,qBAAA,CAAKzB,gBAAA,EAAL,IAAK,EAAiB+E,MAAA,CACpB,IAAI/B,KAAA,CACF,2DACF,CACF;QACF;QACA,OAAOgC,OAAA,CAAQP,GAAA,CAAIC,MAAA,EAAQC,GAAG;MAChC;IACF,CAAC;EACH;EAEAC,UAAUD,GAAA,EAAgC;IACxClD,qBAAA,CAAKjB,aAAA,EAAL,IAAK,EAAcyE,GAAA,CAAIN,GAAG;EAC5B;EAEAO,gBAAA,EAAsE;IACpE,OAAOzD,qBAAA,CAAK9B,aAAA,EAAL,IAAK;EACd;EAEAyB,QAAA,EAEE;IAAA,IAAA+D,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAFuC,CAAC;MAA7BvE,OAAA,GAAA0E,MAAA,CAAAC,MAAA,MAAAC,yBAAA,CAAAN,IAAA,GAAAA,IAAA;IAGX,OAAO,KAAKO,KAAA,CAAAC,aAAA,KACP9E,OAAA,CACJ;EACH;EAEA+E,gBACE/E,OAAA,EAO6C;IAC7C,MAAMgF,gBAAA,GAAmBpE,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQqD,mBAAA,CAAoBjC,OAAO;IAEjE,MAAMyC,KAAA,GAAQ7B,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAChB0D,aAAA,CAAc,EACda,KAAA,CAAMvC,qBAAA,CAAKhC,OAAA,EAAL,IAAK,GAASoG,gBAAgB;IAEvC,OAAOvC,KAAA,CAAMoC,KAAA,CAAM,EAAEI,IAAA,CAAK,MAAM,KAAK5B,YAAA,CAAaZ,KAAA,EAAOuC,gBAAgB,CAAC;EAC5E;EAEUH,MACRK,YAAA,EAC6C;IAAA,IAAAC,qBAAA;IAC7C,OAAOpE,iBAAA,CAAAnB,YAAA,QAAKoB,aAAA,EAAAC,IAAA,CAAL,MAAA6D,aAAA,CAAAA,aAAA,KACFI,YAAA;MACHE,aAAA,GAAAD,qBAAA,GAAeD,YAAA,CAAaE,aAAA,cAAAD,qBAAA,cAAAA,qBAAA,GAAiB;IAAA,IAC5CF,IAAA,CAAK,MAAM;MACZ,KAAK/D,YAAA,CAAa;MAClB,OAAON,qBAAA,CAAK5B,cAAA,EAAL,IAAK;IACd,CAAC;EACH;EAgGUqE,aACRZ,KAAA,EACAzC,OAAA,EAOoC;IACpC,MAAMgC,SAAA,GAAYpB,qBAAA,CAAK9B,aAAA,EAAL,IAAK;IACvB,MAAMiD,WAAA,GAAc,KAAK/B,OAAA;IACzB,MAAMqF,UAAA,GAAazE,qBAAA,CAAK5B,cAAA,EAAL,IAAK;IAGxB,MAAMsG,eAAA,GAAkB1E,qBAAA,CAAK3B,mBAAA,EAAL,IAAK;IAC7B,MAAMsG,iBAAA,GAAoB3E,qBAAA,CAAK1B,qBAAA,EAAL,IAAK;IAC/B,MAAMsG,WAAA,GAAc/C,KAAA,KAAUT,SAAA;IAC9B,MAAMyD,iBAAA,GAAoBD,WAAA,GACtB/C,KAAA,CAAMc,KAAA,GACN3C,qBAAA,CAAK7B,yBAAA,EAAL,IAAK;IAET,MAAM;MAAEwE;IAAM,IAAId,KAAA;IAClB,IAAIiD,QAAA,GAAAZ,aAAA,KAAgBvB,KAAA,CAAM;IAC1B,IAAIoC,iBAAA,GAAoB;IACxB,IAAIC,IAAA;IAGJ,IAAI5F,OAAA,CAAQ6F,kBAAA,EAAoB;MAC9B,MAAMlD,OAAA,GAAU,KAAKtB,YAAA,CAAa;MAElC,MAAMyE,YAAA,GAAe,CAACnD,OAAA,IAAW7B,kBAAA,CAAmB2B,KAAA,EAAOzC,OAAO;MAElE,MAAM+F,eAAA,GACJpD,OAAA,IAAWC,qBAAA,CAAsBH,KAAA,EAAOT,SAAA,EAAWhC,OAAA,EAAS+B,WAAW;MAEzE,IAAI+D,YAAA,IAAgBC,eAAA,EAAiB;QACnCL,QAAA,GAAAZ,aAAA,CAAAA,aAAA,KACKY,QAAA,GACA3H,UAAA,CAAWwF,KAAA,CAAMqC,IAAA,EAAMnD,KAAA,CAAMzC,OAAO,EACzC;MACF;MACA,IAAIA,OAAA,CAAQ6F,kBAAA,KAAuB,eAAe;QAChDH,QAAA,CAASM,WAAA,GAAc;MACzB;IACF;IAEA,IAAI;MAAEC,KAAA;MAAOC,cAAA;MAAgBjC;IAAO,IAAIyB,QAAA;IAGxCE,IAAA,GAAOF,QAAA,CAASE,IAAA;IAChB,IAAIO,UAAA,GAAa;IAGjB,IACEnG,OAAA,CAAQoG,eAAA,KAAoB,UAC5BR,IAAA,KAAS,UACT3B,MAAA,KAAW,WACX;MACA,IAAImC,eAAA;MAGJ,IACEf,UAAA,aAAAA,UAAA,eAAAA,UAAA,CAAYM,iBAAA,IACZ3F,OAAA,CAAQoG,eAAA,MAAoBb,iBAAA,aAAAA,iBAAA,uBAAAA,iBAAA,CAAmBa,eAAA,GAC/C;QACAA,eAAA,GAAkBf,UAAA,CAAWO,IAAA;QAG7BO,UAAA,GAAa;MACf,OAAO;QAAA,IAAAE,sBAAA;QAELD,eAAA,GACE,OAAOpG,OAAA,CAAQoG,eAAA,KAAoB,aAE7BpG,OAAA,CAAQoG,eAAA,EAAAC,sBAAA,GAERzF,qBAAA,CAAKrB,yBAAA,EAAL,IAAK,eAAA8G,sBAAA,uBAALA,sBAAA,CAAgC9C,KAAA,CAAMqC,IAAA,EACtChF,qBAAA,CAAKrB,yBAAA,EAAL,IAAK,CACP,IACAS,OAAA,CAAQoG,eAAA;MAChB;MAEA,IAAIA,eAAA,KAAoB,QAAW;QACjCnC,MAAA,GAAS;QACT2B,IAAA,GAAOvH,WAAA,CACLgH,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYO,IAAA,EACZQ,eAAA,EACApG,OACF;QACA2F,iBAAA,GAAoB;MACtB;IACF;IAIA,IAAI3F,OAAA,CAAQsG,MAAA,IAAUV,IAAA,KAAS,UAAa,CAACO,UAAA,EAAY;MAEvD,IACEd,UAAA,IACAO,IAAA,MAASN,eAAA,aAAAA,eAAA,uBAAAA,eAAA,CAAiBM,IAAA,KAC1B5F,OAAA,CAAQsG,MAAA,KAAW1F,qBAAA,CAAKvB,SAAA,EAAL,IAAK,GACxB;QACAuG,IAAA,GAAOhF,qBAAA,CAAKtB,aAAA,EAAL,IAAK;MACd,OAAO;QACL,IAAI;UACFc,qBAAA,CAAKf,SAAA,EAAL,MAAiBW,OAAA,CAAQsG,MAApB;UACLV,IAAA,GAAO5F,OAAA,CAAQsG,MAAA,CAAOV,IAAW;UACjCA,IAAA,GAAOvH,WAAA,CAAYgH,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYO,IAAA,EAAMA,IAAA,EAAM5F,OAAO;UAClDI,qBAAA,CAAKd,aAAA,EAAL,MAAqBsG,IAAhB;UACLxF,qBAAA,CAAKhB,YAAA,EAAL,MAAoB,IAAf;QACP,SAASmH,WAAA,EAAa;UACpBnG,qBAAA,CAAKhB,YAAA,EAAL,MAAoBmH,WAAf;QACP;MACF;IACF;IAEA,IAAI3F,qBAAA,CAAKxB,YAAA,EAAL,IAAK,GAAc;MACrB6G,KAAA,GAAQrF,qBAAA,CAAKxB,YAAA,EAAL,IAAK;MACbwG,IAAA,GAAOhF,qBAAA,CAAKtB,aAAA,EAAL,IAAK;MACZ4G,cAAA,GAAiBM,IAAA,CAAKC,GAAA,CAAI;MAC1BxC,MAAA,GAAS;IACX;IAEA,MAAMyC,UAAA,GAAahB,QAAA,CAASM,WAAA,KAAgB;IAC5C,MAAMW,SAAA,GAAY1C,MAAA,KAAW;IAC7B,MAAM2C,OAAA,GAAU3C,MAAA,KAAW;IAE3B,MAAM4C,SAAA,GAAYF,SAAA,IAAaD,UAAA;IAC/B,MAAMI,OAAA,GAAUlB,IAAA,KAAS;IAEzB,MAAMxC,MAAA,GAAiD;MACrDa,MAAA;MACA+B,WAAA,EAAaN,QAAA,CAASM,WAAA;MACtBW,SAAA;MACAI,SAAA,EAAW9C,MAAA,KAAW;MACtB2C,OAAA;MACAI,gBAAA,EAAkBH,SAAA;MAClBA,SAAA;MACAjB,IAAA;MACAqB,aAAA,EAAevB,QAAA,CAASuB,aAAA;MACxBhB,KAAA;MACAC,cAAA;MACAgB,YAAA,EAAcxB,QAAA,CAASyB,iBAAA;MACvBC,aAAA,EAAe1B,QAAA,CAAS2B,kBAAA;MACxBC,gBAAA,EAAkB5B,QAAA,CAAS4B,gBAAA;MAC3BC,SAAA,EAAW7B,QAAA,CAAS8B,eAAA,GAAkB,KAAK9B,QAAA,CAAS4B,gBAAA,GAAmB;MACvEG,mBAAA,EACE/B,QAAA,CAAS8B,eAAA,GAAkB/B,iBAAA,CAAkB+B,eAAA,IAC7C9B,QAAA,CAAS4B,gBAAA,GAAmB7B,iBAAA,CAAkB6B,gBAAA;MAChDZ,UAAA;MACAgB,YAAA,EAAchB,UAAA,IAAc,CAACC,SAAA;MAC7BgB,cAAA,EAAgBf,OAAA,IAAW,CAACE,OAAA;MAC5Bc,QAAA,EAAUlC,QAAA,CAASM,WAAA,KAAgB;MACnCL,iBAAA;MACAkC,cAAA,EAAgBjB,OAAA,IAAWE,OAAA;MAC3BgB,OAAA,EAASA,OAAA,CAAQrF,KAAA,EAAOzC,OAAO;MAC/BO,OAAA,EAAS,KAAKA,OAAA;MACdwH,OAAA,EAASnH,qBAAA,CAAKzB,gBAAA,EAAL,IAAK;MACd6I,SAAA,EAAW1J,cAAA,CAAe0B,OAAA,CAAQkC,OAAA,EAASO,KAAK,MAAM;IACxD;IAEA,MAAMwF,UAAA,GAAa7E,MAAA;IAEnB,IAAI,KAAKpD,OAAA,CAAQgE,6BAAA,EAA+B;MAC9C,MAAMkE,0BAAA,GAA8BC,QAAA,IAAqC;QACvE,IAAIF,UAAA,CAAWhE,MAAA,KAAW,SAAS;UACjCkE,QAAA,CAASjE,MAAA,CAAO+D,UAAA,CAAWhC,KAAK;QAClC,WAAWgC,UAAA,CAAWrC,IAAA,KAAS,QAAW;UACxCuC,QAAA,CAASC,OAAA,CAAQH,UAAA,CAAWrC,IAAI;QAClC;MACF;MAKA,MAAMyC,gBAAA,GAAmBA,CAAA,KAAM;QAC7B,MAAMC,OAAA,GACHlI,qBAAA,CAAKjB,gBAAA,EAAL,MACD8I,UAAA,CAAWF,OAAA,GACT9J,eAAA,CAAgB,CAFZ,CAEY;QAEpBiK,0BAAA,CAA2BI,OAAO;MACpC;MAEA,MAAMC,YAAA,GAAe3H,qBAAA,CAAKzB,gBAAA,EAAL,IAAK;MAC1B,QAAQoJ,YAAA,CAAatE,MAAA;QACnB,KAAK;UAGH,IAAIxB,KAAA,CAAM+F,SAAA,KAAcxG,SAAA,CAAUwG,SAAA,EAAW;YAC3CN,0BAAA,CAA2BK,YAAY;UACzC;UACA;QACF,KAAK;UACH,IACEN,UAAA,CAAWhE,MAAA,KAAW,WACtBgE,UAAA,CAAWrC,IAAA,KAAS2C,YAAA,CAAaE,KAAA,EACjC;YACAJ,gBAAA,CAAiB;UACnB;UACA;QACF,KAAK;UACH,IACEJ,UAAA,CAAWhE,MAAA,KAAW,WACtBgE,UAAA,CAAWhC,KAAA,KAAUsC,YAAA,CAAaG,MAAA,EAClC;YACAL,gBAAA,CAAiB;UACnB;UACA;MACJ;IACF;IAEA,OAAOJ,UAAA;EACT;EAEA/G,aAAA,EAAqB;IACnB,MAAMmE,UAAA,GAAazE,qBAAA,CAAK5B,cAAA,EAAL,IAAK;IAIxB,MAAMiJ,UAAA,GAAa,KAAK5E,YAAA,CAAazC,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GAAe,KAAKkB,OAAO;IAErEI,qBAAA,CAAKnB,mBAAA,EAAL,MAA2B2B,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAcyE,KAAzC;IACLnD,qBAAA,CAAKlB,qBAAA,EAAL,MAA6B,KAAKc,OAA7B;IAEL,IAAIY,qBAAA,CAAK3B,mBAAA,EAAL,IAAK,EAAoB2G,IAAA,KAAS,QAAW;MAC/CxF,qBAAA,CAAKb,yBAAA,EAAL,MAAiCqB,qBAAA,CAAK9B,aAAA,EAAL,IAAK,CAAjC;IACP;IAGA,IAAIN,mBAAA,CAAoByJ,UAAA,EAAY5C,UAAU,GAAG;MAC/C;IACF;IAEAjF,qBAAA,CAAKpB,cAAA,EAAL,MAAsBiJ,UAAjB;IAEL,MAAMU,qBAAA,GAAwBA,CAAA,KAAe;MAC3C,IAAI,CAACtD,UAAA,EAAY;QACf,OAAO;MACT;MAEA,MAAM;QAAEuD;MAAoB,IAAI,KAAK5I,OAAA;MACrC,MAAM6I,wBAAA,GACJ,OAAOD,mBAAA,KAAwB,aAC3BA,mBAAA,CAAoB,IACpBA,mBAAA;MAEN,IACEC,wBAAA,KAA6B,SAC5B,CAACA,wBAAA,IAA4B,CAACjI,qBAAA,CAAKjB,aAAA,EAAL,IAAK,EAAcgB,IAAA,EAClD;QACA,OAAO;MACT;MAEA,MAAMmI,aAAA,GAAgB,IAAI3I,GAAA,CACxB0I,wBAAA,aAAAA,wBAAA,cAAAA,wBAAA,GAA4BjI,qBAAA,CAAKjB,aAAA,EAAL,IAAK,CACnC;MAEA,IAAI,KAAKK,OAAA,CAAQ+I,YAAA,EAAc;QAC7BD,aAAA,CAAc1E,GAAA,CAAI,OAAO;MAC3B;MAEA,OAAOM,MAAA,CAAOsE,IAAA,CAAKpI,qBAAA,CAAK5B,cAAc,EAAnB,IAAK,CAAc,EAAEiK,IAAA,CAAMnF,GAAA,IAAQ;QACpD,MAAMoF,QAAA,GAAWpF,GAAA;QACjB,MAAMqF,OAAA,GAAUvI,qBAAA,CAAK5B,cAAA,EAAL,IAAK,EAAekK,QAAQ,MAAM7D,UAAA,CAAW6D,QAAQ;QAErE,OAAOC,OAAA,IAAWL,aAAA,CAAcM,GAAA,CAAIF,QAAQ;MAC9C,CAAC;IACH;IAEAnI,iBAAA,CAAAnB,YAAA,QAAKyJ,OAAA,EAAApI,IAAA,CAAL,MAAa;MAAEP,SAAA,EAAWiI,qBAAA,CAAsB;IAAE,CAAC;EACrD;EAqBAW,cAAA,EAAsB;IACpB,KAAKpI,YAAA,CAAa;IAElB,IAAI,KAAKG,YAAA,CAAa,GAAG;MACvBN,iBAAA,CAAAnB,YAAA,QAAKuB,aAAA,EAAAF,IAAA,CAAL;IACF;EACF;AAkBF;AAAA,SAAAD,cA1ZIkE,YAAA,EACiC;EAEjCnE,iBAAA,CAAAnB,YAAA,QAAKwC,YAAA,EAAAnB,IAAA,CAAL;EAGA,IAAI8G,OAAA,GAA2CnH,qBAAA,CAAK9B,aAAA,EAAL,IAAK,EAAc+F,KAAA,CAChE,KAAK7E,OAAA,EACLkF,YACF;EAEA,IAAI,EAACA,YAAA,aAAAA,YAAA,eAAAA,YAAA,CAAc6D,YAAA,GAAc;IAC/BhB,OAAA,GAAUA,OAAA,CAAQwB,KAAA,CAAMnL,IAAI;EAC9B;EAEA,OAAO2J,OAAA;AACT;AAAA,SAAAjF,oBAAA,EAE4B;EAC1B/B,iBAAA,CAAAnB,YAAA,QAAKgC,kBAAA,EAAAX,IAAA,CAAL;EACA,MAAM4B,SAAA,GAAYtE,gBAAA,CAChB,KAAKyB,OAAA,CAAQ6C,SAAA,EACbjC,qBAAA,CAAK9B,aAAA,EAAL,IAAK,CACP;EAEA,IAAIZ,QAAA,IAAY0C,qBAAA,CAAK5B,cAAA,EAAL,IAAK,EAAe8I,OAAA,IAAW,CAAC3J,cAAA,CAAe0E,SAAS,GAAG;IACzE;EACF;EAEA,MAAM2G,IAAA,GAAO/K,cAAA,CAAemC,qBAAA,CAAK5B,cAAA,EAAL,IAAK,EAAeiI,aAAA,EAAepE,SAAS;EAIxE,MAAM4G,OAAA,GAAUD,IAAA,GAAO;EAEvBpJ,qBAAA,CAAKZ,eAAA,EAAL,MAAuBd,cAAA,CAAegL,UAAA,CAAW,MAAM;IACrD,IAAI,CAAC9I,qBAAA,CAAK5B,cAAA,EAAL,IAAK,EAAe8I,OAAA,EAAS;MAChC,KAAK5G,YAAA,CAAa;IACpB;EACF,GAAGuI,OAAO,CAJL;AAKP;AAAA,SAAAzG,wBAAA,EAE0B;EAAA,IAAA2G,KAAA;EACxB,QAAAA,KAAA,GACG,OAAO,KAAK3J,OAAA,CAAQ4J,eAAA,KAAoB,aACrC,KAAK5J,OAAA,CAAQ4J,eAAA,CAAgBhJ,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,IAC/C,KAAKkB,OAAA,CAAQ4J,eAAA,cAAAD,KAAA,cAAAA,KAAA,GAAoB;AAEzC;AAAA,SAAA1G,uBAEuB4G,YAAA,EAAoC;EACzD9I,iBAAA,CAAAnB,YAAA,QAAKiC,qBAAA,EAAAZ,IAAA,CAAL;EAEAb,qBAAA,CAAKV,uBAAA,EAAL,MAA+BmK,YAA1B;EAEL,IACE3L,QAAA,IACAI,cAAA,CAAe,KAAK0B,OAAA,CAAQkC,OAAA,EAAStB,qBAAA,CAAK9B,aAAa,EAAlB,IAAK,CAAa,MAAM,SAC7D,CAACX,cAAA,CAAeyC,qBAAA,CAAKlB,uBAAuB,EAA5B,IAAK,CAAuB,KAC5CkB,qBAAA,CAAKlB,uBAAA,EAAL,IAAK,MAA4B,GACjC;IACA;EACF;EAEAU,qBAAA,CAAKX,kBAAA,EAAL,MAA0Bf,cAAA,CAAeoL,WAAA,CAAY,MAAM;IACzD,IACE,KAAK9J,OAAA,CAAQ+J,2BAAA,IACblM,YAAA,CAAamM,SAAA,CAAU,GACvB;MACAjJ,iBAAA,CAAAnB,YAAA,QAAKoB,aAAA,EAAAC,IAAA,CAAL;IACF;EACF,GAAGL,qBAAA,CAAKlB,uBAAuB,EAA5B,IAAK,CAAuB,CAP1B;AAQP;AAAA,SAAAyB,cAAA,EAEsB;EACpBJ,iBAAA,CAAAnB,YAAA,QAAKkD,mBAAA,EAAA7B,IAAA,CAAL;EACAF,iBAAA,CAAAnB,YAAA,QAAKqD,sBAAA,EAAAhC,IAAA,CAAL,MAA4BF,iBAAA,CAAAnB,YAAA,QAAKoD,uBAAA,EAAA/B,IAAA,CAAL;AAC9B;AAAA,SAAAW,mBAAA,EAE2B;EACzB,IAAIhB,qBAAA,CAAKpB,eAAA,EAAL,IAAK,GAAiB;IACxBd,cAAA,CAAeuL,YAAA,CAAarJ,qBAAA,CAAKpB,eAAe,EAApB,IAAK,CAAe;IAChDY,qBAAA,CAAKZ,eAAA,EAAL,MAAuB,MAAlB;EACP;AACF;AAAA,SAAAqC,sBAAA,EAE8B;EAC5B,IAAIjB,qBAAA,CAAKnB,kBAAA,EAAL,IAAK,GAAoB;IAC3Bf,cAAA,CAAewL,aAAA,CAActJ,qBAAA,CAAKnB,kBAAkB,EAAvB,IAAK,CAAkB;IACpDW,qBAAA,CAAKX,kBAAA,EAAL,MAA0B,MAArB;EACP;AACF;AAAA,SAAA2C,aAAA,EAoRqB;EACnB,MAAMK,KAAA,GAAQ7B,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQ0D,aAAA,CAAc,EAAEa,KAAA,CAAMvC,qBAAA,CAAKhC,OAAA,EAAL,IAAK,GAAS,KAAKoB,OAAO;EAE3E,IAAIyC,KAAA,KAAU7B,qBAAA,CAAK9B,aAAA,EAAL,IAAK,GAAe;IAChC;EACF;EAEA,MAAMkD,SAAA,GAAYpB,qBAAA,CAAK9B,aAAA,EAAL,IAAK;EAGvBsB,qBAAA,CAAKtB,aAAA,EAAL,MAAqB2D,KAAhB;EACLrC,qBAAA,CAAKrB,yBAAA,EAAL,MAAiC0D,KAAA,CAAMc,KAAlC;EAEL,IAAI,KAAKlC,YAAA,CAAa,GAAG;IACvBW,SAAA,aAAAA,SAAA,eAAAA,SAAA,CAAWF,cAAA,CAAe,IAAI;IAC9BW,KAAA,CAAM5B,WAAA,CAAY,IAAI;EACxB;AACF;AAAA,SAAAwI,QAUQc,aAAA,EAA6C;EACnDrM,aAAA,CAAcsM,KAAA,CAAM,MAAM;IAExB,IAAID,aAAA,CAAczJ,SAAA,EAAW;MAC3B,KAAKA,SAAA,CAAU2J,OAAA,CAASC,QAAA,IAAa;QACnCA,QAAA,CAAS1J,qBAAA,CAAK5B,cAAc,EAAnB,IAAK,CAAc;MAC9B,CAAC;IACH;IAGA4B,qBAAA,CAAKhC,OAAA,EAAL,IAAK,EAAQ0D,aAAA,CAAc,EAAEC,MAAA,CAAO;MAClCE,KAAA,EAAO7B,qBAAA,CAAK9B,aAAA,EAAL,IAAK;MACZ0D,IAAA,EAAM;IACR,CAAC;EACH,CAAC;AACH;AAGF,SAAS+H,kBACP9H,KAAA,EACAzC,OAAA,EACS;EACT,OACE1B,cAAA,CAAe0B,OAAA,CAAQkC,OAAA,EAASO,KAAK,MAAM,SAC3CA,KAAA,CAAMc,KAAA,CAAMqC,IAAA,KAAS,UACrB,EAAEnD,KAAA,CAAMc,KAAA,CAAMU,MAAA,KAAW,WAAWjE,OAAA,CAAQwK,YAAA,KAAiB;AAEjE;AAEA,SAAS1J,mBACP2B,KAAA,EACAzC,OAAA,EACS;EACT,OACEuK,iBAAA,CAAkB9H,KAAA,EAAOzC,OAAO,KAC/ByC,KAAA,CAAMc,KAAA,CAAMqC,IAAA,KAAS,UACpBpE,aAAA,CAAciB,KAAA,EAAOzC,OAAA,EAASA,OAAA,CAAQyK,cAAc;AAE1D;AAEA,SAASjJ,cACPiB,KAAA,EACAzC,OAAA,EACA0K,KAAA,EAGA;EACA,IACEpM,cAAA,CAAe0B,OAAA,CAAQkC,OAAA,EAASO,KAAK,MAAM,SAC3ClE,gBAAA,CAAiByB,OAAA,CAAQ6C,SAAA,EAAWJ,KAAK,MAAM,UAC/C;IACA,MAAMgG,KAAA,GAAQ,OAAOiC,KAAA,KAAU,aAAaA,KAAA,CAAMjI,KAAK,IAAIiI,KAAA;IAE3D,OAAOjC,KAAA,KAAU,YAAaA,KAAA,KAAU,SAASX,OAAA,CAAQrF,KAAA,EAAOzC,OAAO;EACzE;EACA,OAAO;AACT;AAEA,SAAS4C,sBACPH,KAAA,EACAT,SAAA,EACAhC,OAAA,EACA+B,WAAA,EACS;EACT,QACGU,KAAA,KAAUT,SAAA,IACT1D,cAAA,CAAeyD,WAAA,CAAYG,OAAA,EAASO,KAAK,MAAM,WAChD,CAACzC,OAAA,CAAQ2K,QAAA,IAAYlI,KAAA,CAAMc,KAAA,CAAMU,MAAA,KAAW,YAC7C6D,OAAA,CAAQrF,KAAA,EAAOzC,OAAO;AAE1B;AAEA,SAAS8H,QACPrF,KAAA,EACAzC,OAAA,EACS;EACT,OACE1B,cAAA,CAAe0B,OAAA,CAAQkC,OAAA,EAASO,KAAK,MAAM,SAC3CA,KAAA,CAAMmI,aAAA,CAAcrM,gBAAA,CAAiByB,OAAA,CAAQ6C,SAAA,EAAWJ,KAAK,CAAC;AAElE;AAIA,SAASa,sCAOPZ,QAAA,EACAmI,gBAAA,EACA;EAGA,IAAI,CAACrM,mBAAA,CAAoBkE,QAAA,CAASc,gBAAA,CAAiB,GAAGqH,gBAAgB,GAAG;IACvE,OAAO;EACT;EAGA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}